<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CuteDSP - Real-time Audio Processing Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group h3 {
            margin-top: 0;
            color: #ffd700;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .control-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
        }

        .status.active {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
        }

        .status.inactive {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
        }

        .visualizer {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .buttons {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info h3 {
            color: #ffd700;
            margin-top: 0;
        }

        .fft-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .spectrum {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .spectrum h4 {
            margin-top: 0;
            color: #ffd700;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ CuteDSP - Real-time Audio Processing</h1>

        <div class="status inactive" id="status">
            <strong>Status:</strong> Click "Start Audio" to begin real-time processing
        </div>

        <div class="buttons">
            <button id="startBtn">üé§ Start Audio</button>
            <button id="stopBtn" disabled>‚èπÔ∏è Stop Audio</button>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üéõÔ∏è Filter Controls</h3>
                <label>
                    <input type="checkbox" id="filterEnabled" checked> Enable Filter
                </label>
                <label for="filterType">Filter Type:</label>
                <select id="filterType">
                    <option value="lowpass">Low Pass</option>
                    <option value="highpass">High Pass</option>
                    <option value="bandpass">Band Pass</option>
                </select>
                <label for="filterFreq">Frequency: <span id="filterFreqValue">1000</span> Hz</label>
                <input type="range" id="filterFreq" min="100" max="8000" value="1000" step="50">
                <label for="filterQ">Q Factor: <span id="filterQValue">0.7</span></label>
                <input type="range" id="filterQ" min="0.1" max="5.0" value="0.7" step="0.1">
            </div>

            <div class="control-group">
                <h3>‚è∞ Delay Controls</h3>
                <label>
                    <input type="checkbox" id="delayEnabled"> Enable Delay
                </label>
                <label for="delayTime">Delay Time: <span id="delayTimeValue">200</span> ms</label>
                <input type="range" id="delayTime" min="50" max="1000" value="200" step="10">
                <label for="delayFeedback">Feedback: <span id="delayFeedbackValue">0.3</span></label>
                <input type="range" id="delayFeedback" min="0.0" max="0.9" value="0.3" step="0.05">
            </div>

            <div class="control-group">
                <h3>üåä Modulation</h3>
                <label>
                    <input type="checkbox" id="modulationEnabled"> Enable Tremolo
                </label>
                <label for="modFreq">Modulation Frequency: <span id="modFreqValue">5</span> Hz</label>
                <input type="range" id="modFreq" min="0.5" max="20" value="5" step="0.5">
                <label for="modDepth">Modulation Depth: <span id="modDepthValue">0.5</span></label>
                <input type="range" id="modDepth" min="0.0" max="1.0" value="0.5" step="0.05">
            </div>

            <div class="control-group">
                <h3>üéöÔ∏è Gain & Effects</h3>
                <label for="masterGain">Master Gain: <span id="masterGainValue">1.0</span></label>
                <input type="range" id="masterGain" min="0.0" max="2.0" value="1.0" step="0.1">
                <label for="dryWet">Dry/Wet Mix: <span id="dryWetValue">0.5</span></label>
                <input type="range" id="dryWet" min="0.0" max="1.0" value="0.5" step="0.05">
            </div>
        </div>

        <div class="fft-display">
            <div class="spectrum">
                <h4>Input Spectrum</h4>
                <canvas id="inputCanvas"></canvas>
            </div>
            <div class="spectrum">
                <h4>Output Spectrum</h4>
                <canvas id="outputCanvas"></canvas>
            </div>
        </div>

        <div class="visualizer">
            <canvas id="waveformCanvas"></canvas>
        </div>

        <div class="info">
            <h3>‚ÑπÔ∏è About This Demo</h3>
            <p>This demo showcases the CuteDSP library running entirely in WebAssembly! It processes your microphone input in real-time using:</p>
            <ul>
                <li><strong>FFT Analysis:</strong> Real-time frequency domain visualization</li>
                <li><strong>Biquad Filters:</strong> Low-pass, high-pass, and band-pass filtering</li>
                <li><strong>Delay Effects:</strong> Echo/delay with feedback control</li>
                <li><strong>Tremolo:</strong> Amplitude modulation effects</li>
                <li><strong>STFT Processing:</strong> Short-time Fourier transform for advanced analysis</li>
            </ul>
            <p>All processing happens at native speed thanks to Rust/WebAssembly compilation.</p>
        </div>
    </div>

    <!-- Load the WASM module -->
    <script src="pkg/cute_dsp.js"></script>

    <script>
        // Audio processing variables
        let audioContext = null;
        let microphone = null;
        let processor = null;
        let isProcessing = false;

        // DSP objects
        let fft = null;
        let filter = null;
        let delay = null;
        let lfo = null;
        let stft = null;

        // Buffers
        let inputBuffer = new Float32Array(2048);
        let outputBuffer = new Float32Array(2048);
        let fftReal = new Float32Array(1024);
        let fftImag = new Float32Array(1024);
        let fftMag = new Float32Array(512);

        // Canvas contexts
        let waveformCanvas = null;
        let inputCanvas = null;
        let outputCanvas = null;

        // Control values
        let controls = {
            filterEnabled: true,
            filterType: 'lowpass',
            filterFreq: 1000,
            filterQ: 0.7,
            delayEnabled: false,
            delayTime: 200,
            delayFeedback: 0.3,
            modulationEnabled: false,
            modFreq: 5,
            modDepth: 0.5,
            masterGain: 1.0,
            dryWet: 0.5
        };

        // Initialize when WASM loads
        window.addEventListener('load', async () => {
            try {
                // Initialize WASM
                await wasm_bindgen();

                // Create DSP objects
                fft = new wasm_bindgen.WasmFFT(1024);
                filter = new wasm_bindgen.WasmBiquad();
                delay = new wasm_bindgen.WasmDelay(44100); // 1 second max delay
                lfo = new wasm_bindgen.WasmLFO();
                stft = new wasm_bindgen.WasmSTFT(false); // false for non-modified STFT
                stft.configure(1, 1, 512); // mono input/output, 512 block size

                // Get canvas contexts
                waveformCanvas = document.getElementById('waveformCanvas').getContext('2d');
                inputCanvas = document.getElementById('inputCanvas').getContext('2d');
                outputCanvas = document.getElementById('outputCanvas').getContext('2d');

                // Setup controls
                setupControls();

                console.log('üéµ CuteDSP WASM initialized successfully!');
                updateStatus('Ready to start audio processing', true);

            } catch (error) {
                console.error('Failed to initialize WASM:', error);
                updateStatus('Failed to initialize WASM: ' + error.message, false);
            }
        });

        function setupControls() {
            // Filter controls
            document.getElementById('filterEnabled').addEventListener('change', (e) => {
                controls.filterEnabled = e.target.checked;
            });

            document.getElementById('filterType').addEventListener('change', (e) => {
                controls.filterType = e.target.value;
                updateFilter();
            });

            document.getElementById('filterFreq').addEventListener('input', (e) => {
                controls.filterFreq = parseFloat(e.target.value);
                document.getElementById('filterFreqValue').textContent = controls.filterFreq;
                updateFilter();
            });

            document.getElementById('filterQ').addEventListener('input', (e) => {
                controls.filterQ = parseFloat(e.target.value);
                document.getElementById('filterQValue').textContent = controls.filterQ.toFixed(1);
                updateFilter();
            });

            // Delay controls
            document.getElementById('delayEnabled').addEventListener('change', (e) => {
                controls.delayEnabled = e.target.checked;
            });

            document.getElementById('delayTime').addEventListener('input', (e) => {
                controls.delayTime = parseFloat(e.target.value);
                document.getElementById('delayTimeValue').textContent = controls.delayTime;
            });

            document.getElementById('delayFeedback').addEventListener('input', (e) => {
                controls.delayFeedback = parseFloat(e.target.value);
                document.getElementById('delayFeedbackValue').textContent = controls.delayFeedback.toFixed(1);
            });

            // Modulation controls
            document.getElementById('modulationEnabled').addEventListener('change', (e) => {
                controls.modulationEnabled = e.target.checked;
            });

            document.getElementById('modFreq').addEventListener('input', (e) => {
                controls.modFreq = parseFloat(e.target.value);
                document.getElementById('modFreqValue').textContent = controls.modFreq;
            });

            document.getElementById('modDepth').addEventListener('input', (e) => {
                controls.modDepth = parseFloat(e.target.value);
                document.getElementById('modDepthValue').textContent = controls.modDepth.toFixed(1);
            });

            // Gain controls
            document.getElementById('masterGain').addEventListener('input', (e) => {
                controls.masterGain = parseFloat(e.target.value);
                document.getElementById('masterGainValue').textContent = controls.masterGain.toFixed(1);
            });

            document.getElementById('dryWet').addEventListener('input', (e) => {
                controls.dryWet = parseFloat(e.target.value);
                document.getElementById('dryWetValue').textContent = controls.dryWet.toFixed(1);
            });
        }

        function updateFilter() {
            if (!filter) return;

            const normalizedFreq = controls.filterFreq / 22050; // Assuming 44.1kHz sample rate

            switch (controls.filterType) {
                case 'lowpass':
                    filter.lowpass(normalizedFreq, controls.filterQ);
                    break;
                case 'highpass':
                    filter.highpass(normalizedFreq, controls.filterQ);
                    break;
                case 'bandpass':
                    filter.bandpass(normalizedFreq, 1.0); // bandwidth in octaves
                    break;
            }
        }

        function updateStatus(message, isActive) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + (isActive ? 'active' : 'inactive');
        }

        // Audio processing function
        function processAudio(input, output) {
            const inputChannel = input[0];
            const outputChannel = output[0];

            // Copy input to our buffer
            for (let i = 0; i < inputChannel.length; i++) {
                inputBuffer[i] = inputChannel[i];
            }

            // Process through DSP chain
            for (let i = 0; i < inputChannel.length; i++) {
                let sample = inputChannel[i];

                // Apply filter
                if (controls.filterEnabled) {
                    sample = filter.process([sample], [0])[0];
                }

                // Apply delay
                if (controls.delayEnabled) {
                    const delaySamples = (controls.delayTime / 1000) * 44100;
                    const delayed = delay.process(sample, delaySamples);
                    sample = sample + delayed * controls.delayFeedback;
                }

                // Apply tremolo
                if (controls.modulationEnabled) {
                    lfo.set_params(0.0, 1.0, controls.modFreq, 0.0, 0.0); // low, high, rate, rate_variation, depth_variation
                    const modSignal = lfo.process();
                    const modulation = 1.0 - controls.modDepth * modSignal;
                    sample *= modulation;
                }

                // Apply dry/wet mix
                sample = inputChannel[i] * (1 - controls.dryWet) + sample * controls.dryWet;

                // Apply master gain
                sample *= controls.masterGain;

                outputChannel[i] = sample;
                outputBuffer[i] = sample;
            }

            // Update visualizations
            updateVisualizations();
        }

        function updateVisualizations() {
            // Waveform
            drawWaveform(waveformCanvas, inputBuffer, outputBuffer);

            // FFT analysis
            analyzeSpectrum(inputBuffer, outputBuffer);
        }

        function drawWaveform(ctx, input, output) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Draw input waveform (blue)
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const inputStep = input.length / width;
            for (let x = 0; x < width; x++) {
                const sampleIndex = Math.floor(x * inputStep);
                const y = (input[sampleIndex] * 0.5 + 0.5) * height;
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Draw output waveform (green)
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();

            const outputStep = output.length / width;
            for (let x = 0; x < width; x++) {
                const sampleIndex = Math.floor(x * outputStep);
                const y = (output[sampleIndex] * 0.5 + 0.5) * height;
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function analyzeSpectrum(input, output) {
            // Perform FFT on input
            for (let i = 0; i < 1024; i++) {
                fftReal[i] = i < input.length ? input[i] : 0;
                fftImag[i] = 0;
            }

            fft.fft_forward(fftReal, fftImag, fftReal, fftImag);

            // Calculate magnitude for input spectrum
            for (let i = 0; i < 512; i++) {
                const mag = Math.sqrt(fftReal[i] * fftReal[i] + fftImag[i] * fftImag[i]);
                fftMag[i] = 20 * Math.log10(mag + 1e-10); // Convert to dB
            }

            drawSpectrum(inputCanvas, fftMag, '#00ffff');

            // Perform FFT on output
            for (let i = 0; i < 1024; i++) {
                fftReal[i] = i < output.length ? output[i] : 0;
                fftImag[i] = 0;
            }

            fft.fft_forward(fftReal, fftImag, fftReal, fftImag);

            // Calculate magnitude for output spectrum
            for (let i = 0; i < 512; i++) {
                const mag = Math.sqrt(fftReal[i] * fftReal[i] + fftImag[i] * fftImag[i]);
                fftMag[i] = 20 * Math.log10(mag + 1e-10); // Convert to dB
            }

            drawSpectrum(outputCanvas, fftMag, '#00ff00');
        }

        function drawSpectrum(ctx, magnitudes, color) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            const step = magnitudes.length / width;
            for (let x = 0; x < width; x++) {
                const magIndex = Math.floor(x * step);
                const magnitude = magnitudes[magIndex];
                // Map dB range (-100 to 0) to canvas height
                const y = height - ((magnitude + 100) / 100) * height;
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        // Audio control functions
        async function startAudio() {
            try {
                // Create audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Get microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);

                // Create script processor for real-time processing
                processor = audioContext.createScriptProcessor(2048, 1, 1);
                processor.onaudioprocess = (event) => {
                    if (isProcessing) {
                        processAudio(event.inputBuffer, event.outputBuffer);
                    }
                };

                // Connect the audio graph
                microphone.connect(processor);
                processor.connect(audioContext.destination);

                isProcessing = true;

                // Update UI
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                updateStatus('üéµ Audio processing active - speak into your microphone!', true);

            } catch (error) {
                console.error('Failed to start audio:', error);
                updateStatus('Failed to start audio: ' + error.message, false);
            }
        }

        function stopAudio() {
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            isProcessing = false;

            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus('Audio processing stopped', false);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startAudio);
        document.getElementById('stopBtn').addEventListener('click', stopAudio);

        // Initialize filter
        updateFilter();
    </script>
</body>
</html>
            return;
        }

        try {
            // Create FFT instance
            const fft = new wasm_bindgen.WasmFFT(8);

            // Create test signal: [1, 0, 0, 0, 0, 0, 0, 0]
            const realIn = new Float32Array([1, 0, 0, 0, 0, 0, 0, 0]);
            const imagIn = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
            const realOut = new Float32Array(8);
            const imagOut = new Float32Array(8);

            // Perform FFT
            fft.fft_forward(realIn, imagIn, realOut, imagOut);

            // Display results
            let result = 'FFT Result:<br>';
            result += 'Input: [';
            for (let i = 0; i < 8; i++) {
                result += `${realIn[i].toFixed(2)}${imagIn[i] !== 0 ? `+${imagIn[i].toFixed(2)}i` : ''}`;
                if (i < 7) result += ', ';
            }
            result += ']<br>Output: [';
            for (let i = 0; i < 8; i++) {
                result += `${realOut[i].toFixed(2)}${imagOut[i] >= 0 ? '+' : ''}${imagOut[i].toFixed(2)}i`;
                if (i < 7) result += ', ';
            }
            result += ']';

            document.getElementById('fft-result').innerHTML = result;
        } catch (error) {
            document.getElementById('fft-result').textContent = 'FFT Error: ' + error.message;
        }
    }

    function runFilter() {
        if (!wasmReady) {
            alert('WASM not ready yet');
            return;
        }

        try {
            // Create biquad filter
            const filter = new wasm_bindgen.WasmBiquad();
            filter.lowpass(0.1, 0.7); // Lowpass at 0.1 * Nyquist, Q=0.7

            // Test signal: impulse response
            const input = new Float32Array([1, 0, 0, 0, 0, 0, 0, 0]);
            const output = new Float32Array(8);

            filter.process(input, output);

            let result = 'Filter Response:<br>Input: [';
            for (let i = 0; i < 8; i++) {
                result += input[i].toFixed(2);
                if (i < 7) result += ', ';
            }
            result += ']<br>Output: [';
            for (let i = 0; i < 8; i++) {
                result += output[i].toFixed(4);
                if (i < 7) result += ', ';
            }
            result += ']';

            document.getElementById('filter-result').innerHTML = result;
        } catch (error) {
            document.getElementById('filter-result').textContent = 'Filter Error: ' + error.message;
        }
    }

    function runWindow() {
        if (!wasmReady) {
            alert('WASM not ready yet');
            return;
        }

        try {
            // Create Kaiser window
            const window = wasm_bindgen.WasmKaiser.with_bandwidth(0.1);
            const data = new Float32Array(8);

            window.fill(data);

            let result = 'Kaiser Window:<br>[';
            for (let i = 0; i < 8; i++) {
                result += data[i].toFixed(4);
                if (i < 7) result += ', ';
            }
            result += ']';

            document.getElementById('window-result').innerHTML = result;
        } catch (error) {
            document.getElementById('window-result').textContent = 'Window Error: ' + error.message;
        }
    }

    function runSpectral() {
        if (!wasmReady) {
            alert('WASM not ready yet');
            return;
        }

        try {
            // Test spectral utilities
            const complex = wasm_bindgen.WasmSpectralUtils.mag_phase_to_complex(2.0, Math.PI/4);
            const magPhase = wasm_bindgen.WasmSpectralUtils.complex_to_mag_phase(complex[0], complex[1]);
            const dbValue = wasm_bindgen.WasmSpectralUtils.linear_to_db(10.0);

            let result = 'Spectral Utils:<br>';
            result += `Mag/Phase to Complex: (2.0, œÄ/4) ‚Üí (${complex[0].toFixed(3)}, ${complex[1].toFixed(3)})<br>`;
            result += `Complex to Mag/Phase: (${complex[0].toFixed(3)}, ${complex[1].toFixed(3)}) ‚Üí (${magPhase[0].toFixed(3)}, ${magPhase[1].toFixed(3)})<br>`;
            result += `Linear to dB: 10.0 ‚Üí ${dbValue.toFixed(2)} dB`;

            document.getElementById('spectral-result').innerHTML = result;
        } catch (error) {
            document.getElementById('spectral-result').textContent = 'Spectral Error: ' + error.message;
        }
    }

    function runCurve() {
        if (!wasmReady) {
            alert('WASM not ready yet');
            return;
        }

        try {
            // Test curve mapping
            const curve = wasm_bindgen.WasmLinearCurve.from_points(0.0, 1.0, 0.0, 100.0);
            const values = [0.0, 0.25, 0.5, 0.75, 1.0];
            const mapped = values.map(v => curve.evaluate(v));

            let result = 'Linear Curve Mapping (0‚Üí1 to 0‚Üí100):<br>';
            for (let i = 0; i < values.length; i++) {
                result += `${values[i]} ‚Üí ${mapped[i].toFixed(1)}`;
                if (i < values.length - 1) result += ', ';
            }

            document.getElementById('curve-result').innerHTML = result;
        } catch (error) {
            document.getElementById('curve-result').textContent = 'Curve Error: ' + error.message;
        }
    }
    </script>
</body>
</html>